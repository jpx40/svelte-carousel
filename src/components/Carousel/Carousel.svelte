<script>
  import { run } from 'svelte/legacy';

  import { onDestroy, onMount, tick, createEventDispatcher } from 'svelte'
  import Dots from '../Dots/Dots.svelte'
  import Arrow from '../Arrow/Arrow.svelte'
  import Progress from '../Progress/Progress.svelte'
  import { NEXT, PREV } from '../../direction'
  import { swipeable } from '../../actions/swipeable'
  import { hoverable } from '../../actions/hoverable'
  import { tappable } from '../../actions/tappable'
  import {
    applyParticleSizes,
    createResizeObserver,
  } from '../../utils/page'
  import {
    getClones,
    applyClones,
  } from '../../utils/clones'
  import { get, switcher } from '../../utils/object'
  import createCarousel from './createCarousel'

  // used for lazy loading images, preloaded only current, adjacent and cloanable images
  let loaded = $state([])
  let currentPageIndex = $state()
  run(() => {
    dispatch('pageChange', currentPageIndex)
  });

  let progressValue = $state()
  let offset = $state(0)
  let durationMs = $state(0)
  let pagesCount = $state(1)

  const [{ data, progressManager }, methods, service] = $state(createCarousel((key, value) => {
    switcher({
      'currentPageIndex': () => currentPageIndex = value,
      'progressValue': () => progressValue = value,
      'offset': () => offset = value,
      'durationMs': () => durationMs = value,
      'pagesCount': () => pagesCount = value,
      'loaded': () => loaded = value,
    })(key)
  }))

  const dispatch = createEventDispatcher()

  

  

  
  run(() => {
    data.infinite = infinite
  });

  

  
  run(() => {
    data.durationMsInit = duration
  });

  
  run(() => {
    data.autoplay = autoplay
  });

  
  run(() => {
    data.autoplayDuration = autoplayDuration
  });

  
  run(() => {
    data.autoplayDirection = autoplayDirection
  });

  
  run(() => {
    data.pauseOnFocus = pauseOnFocus
  });

  

  

  

  
  run(() => {
    data.particlesToShowInit = particlesToShow
  });

  
  /** @type {{timingFunction?: string, arrows?: boolean, infinite?: boolean, initialPageIndex?: number, duration?: number, autoplay?: boolean, autoplayDuration?: number, autoplayDirection?: any, pauseOnFocus?: boolean, autoplayProgressVisible?: boolean, dots?: boolean, swiping?: boolean, particlesToShow?: number, particlesToScroll?: number, prev?: import('svelte').Snippet<[any]>, children?: import('svelte').Snippet<[any]>, next?: import('svelte').Snippet<[any]>, dots_1?: import('svelte').Snippet<[any]>}} */
  let {
    timingFunction = 'ease-in-out',
    arrows = true,
    infinite = true,
    initialPageIndex = 0,
    duration = 500,
    autoplay = false,
    autoplayDuration = 3000,
    autoplayDirection = NEXT,
    pauseOnFocus = false,
    autoplayProgressVisible = false,
    dots = true,
    swiping = true,
    particlesToShow = 1,
    particlesToScroll = 1,
    prev,
    children,
    next,
    dots_1
  } = $props();
  run(() => {
    data.particlesToScrollInit = particlesToScroll
  });

  export async function goTo(pageIndex, options) {
    const animated = get(options, 'animated', true)
    if (typeof pageIndex !== 'number') {
      throw new Error('pageIndex should be a number')
    }
    await methods.showPage(pageIndex, { animated })
  }

  export async function goToPrev(options) {
    const animated = get(options, 'animated', true)
    await methods.showPrevPage({ animated })
  }

  export async function goToNext(options) {
    const animated = get(options, 'animated', true)
    await methods.showNextPage({ animated })
  }

  let pageWindowWidth = $state(0)
  let pageWindowElement = $state()
  let particlesContainer = $state()

  const pageWindowElementResizeObserver = createResizeObserver(({
    width,
  }) => {
    pageWindowWidth = width
    data.particleWidth = pageWindowWidth / data.particlesToShow

    applyParticleSizes({
      particlesContainerChildren: particlesContainer.children,
      particleWidth: data.particleWidth,
    })
    methods.offsetPage({ animated: false })
  })

  function addClones() {
    const {
      clonesToAppend,
      clonesToPrepend,
    } = getClones({
      clonesCountHead: data.clonesCountHead,
      clonesCountTail: data.clonesCountTail,
      particlesContainerChildren: particlesContainer.children,
    })
    applyClones({
      particlesContainer,
      clonesToAppend,
      clonesToPrepend,
    })
  }

  onMount(() => {
    (async () => {
      await tick()
      if (particlesContainer && pageWindowElement) {
        data.particlesCountWithoutClones = particlesContainer.children.length

        await tick()
        data.infinite && addClones()

        // call after adding clones
        data.particlesCount = particlesContainer.children.length

        methods.showPage(initialPageIndex, { animated: false })

        pageWindowElementResizeObserver.observe(pageWindowElement);
      }
    })()
  })

  onDestroy(() => {
    pageWindowElementResizeObserver.disconnect()
    progressManager.reset()
  })

  async function handlePageChange(pageIndex) {
    await methods.showPage(pageIndex, { animated: true })
  }

  // gestures
  function handleSwipeStart() {
    if (!swiping) return
    data.durationMs = 0
  }
  async function handleSwipeThresholdReached(event) {
    if (!swiping) return
    await switcher({
      [NEXT]: methods.showNextPage,
      [PREV]: methods.showPrevPage
    })(event.detail.direction)
  }
  function handleSwipeMove(event) {
    if (!swiping) return
    data.offset += event.detail.dx
  }
  function handleSwipeEnd() {
    if (!swiping) return
    methods.showParticle(data.currentParticleIndex)
  }
  async function handleSwipeFailed() {
    if (!swiping) return
    await methods.offsetPage({ animated: true })
  }

  function handleHovered(event) {
    data.focused = event.detail.value
  }
  function handleTapped() {
    methods.toggleFocused()
  }

  function showPrevPage() {
    methods.showPrevPage()
  }
</script>

<div class="sc-carousel__carousel-container">
  <div class="sc-carousel__content-container">
    {#if arrows}
      {#if prev}{@render prev({ showPrevPage: {methods.showPrevPage}, })}{:else}
        <div class="sc-carousel__arrow-container">
          <Arrow
            direction="prev"
            disabled={!infinite && currentPageIndex === 0}
            on:click={showPrevPage}
          />
        </div>
      {/if}
    {/if}
    <div
      class="sc-carousel__pages-window"
      bind:this={pageWindowElement}

      use:hoverable
      onhovered={handleHovered}

      use:tappable
      ontapped={handleTapped}
    >
      <div
        class="sc-carousel__pages-container"
        use:swipeable="{{ thresholdProvider: () => pageWindowWidth/3 }}"
        onswipeStart={handleSwipeStart}
        onswipeMove={handleSwipeMove}
        onswipeEnd={handleSwipeEnd}
        onswipeFailed={handleSwipeFailed}
        onswipeThresholdReached={handleSwipeThresholdReached}
        style="
          transform: translateX({offset}px);
          transition-duration: {durationMs}ms;
          transition-timing-function: {timingFunction};
        "
        bind:this={particlesContainer}
      >
        {@render children?.({ loaded, currentPageIndex, })}
      </div>
      {#if autoplayProgressVisible}
        <div class="sc-carousel-progress__container">
          <Progress value={progressValue} />
        </div>
      {/if}
    </div>
    {#if arrows}
      {#if next}{@render next({ showNextPage: {methods.showNextPage}, })}{:else}
        <div class="sc-carousel__arrow-container">
          <Arrow
            direction="next"
            disabled={!infinite && currentPageIndex === pagesCount - 1}
            on:click={methods.showNextPage}
          />
        </div>
      {/if}
    {/if}
  </div>
  {#if dots}
    {#if dots_1}{@render dots_1({ currentPageIndex: {currentPageIndex}, pagesCount: {pagesCount}, showPage: {handlePageChange}, })}{:else}
      <Dots
        pagesCount={pagesCount}
        currentPageIndex={currentPageIndex}
        on:pageChange={event => handlePageChange(event.detail)}
      ></Dots>
    {/if}
  {/if}
</div>

<style>
  :root {
    --sc-color-rgb-light-50p: rgba(93, 93, 93, 0.5);
    --sc-color-rgb-light: #5d5d5d;
    --sc-color-hex-dark-50p: rgba(30, 30, 30, 0.5);
    --sc-color-hex-dark: #1e1e1e;
  }
  .sc-carousel__carousel-container {
    display: flex;
    width: 100%;
    flex-direction: column;
    align-items: center;
  }
  .sc-carousel__content-container {
    position: relative;
    display: flex;
    width: 100%;
  }
  .sc-carousel__pages-window {
    flex: 1;
    display: flex;
    overflow: hidden;
    box-sizing: border-box;
    position: relative;
  }
  .sc-carousel__pages-container {
    width: 100%;
    display: flex; /* to put child elements in one row */
    transition-property: transform;
  }
  .sc-carousel__arrow-container {
    padding: 5px;
    box-sizing: border-box;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .sc-carousel-progress__container {
    width: 100%;
    height: 5px;
    background-color: var(--sc-color-rgb-light-50p);
    position: absolute;
    bottom: 0;
  }
  :global(.sc-carousel-button) {
    all: unset;
    cursor: pointer;
  }
  :global(.sc-carousel-button:focus) {
    outline: 5px auto;
  }
</style>
